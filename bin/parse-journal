#!/usr/bin/php
<?php
/**
 * Copyright 2016 FranÃ§ois Kooman <fkooman@tuxed.net>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the systemd journal.
 *
 * Usage:
 *
 * $ sudo journalctl \
 *     -o json \
 *     -t vpn-server-api-client-connect \
 *     -t vpn-server-api-client-disconnect \
 *     | vpn-server-api-parse-journal
 */

/**
 * Due to not wanting to store all user data forever, we have a log window 
 * after which log entries disappear from the system, this can result in some
 * issues. The log window is typically 1 month.
 *
 * LIMITATIONS:
 *
 * - if a client connected before this logging window started, it is not 
 *   visible in the logs;
 * - if a client stays connected for the whole logging window, it is not 
 *   available in the log at all;
 * - if a client was connected before the logging window started and 
 *   disconnected during, it is not added to the log;
 */
$clientConnectSyslogIdentifier = 'vpn-server-api-client-connect';
$clientDisconnectSyslogIdentifier = 'vpn-server-api-client-disconnect';

$logData = [];

// every line is a JSON object
while ($jsonLine = fgets(STDIN)) {
    $jsonData = json_decode($jsonLine, true);

    if ($clientConnectSyslogIdentifier === $jsonData['SYSLOG_IDENTIFIER']) {

        // handle connect data
        $message = $jsonData['MESSAGE'];
        $messageData = json_decode($message, true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            // XXX if an error occurred decoding the message, it was 
            // probably a log error message, ignore them for now, but later we
            // will need them as well!
            continue;
        }

        $commonName = $messageData['common_name'];
        $userId = explode('_', $commonName, 2)[0];
        $configName = explode('_', $commonName, 2)[1];

        $logKey = sprintf('%s:%s', $messageData['common_name'], $messageData['time_unix']);
        $logData[$logKey] = [
            'user_id' => $userId,
            'config_name' => $configName,
            'v4' => $messageData['v4'],
            'v6' => $messageData['v6'],
            'connect_time' => intval($messageData['time_unix']),
        ];
    }

    if ($clientDisconnectSyslogIdentifier === $jsonData['SYSLOG_IDENTIFIER']) {
        // handle connect data
        $message = $jsonData['MESSAGE'];
        $messageData = json_decode($message, true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            // XXX if an error occurred decoding the message, it was 
            // probably a log error message, ignore them for now, but later we
            // will need them as well!
            continue;
        }

        $logKey = sprintf('%s:%s', $messageData['common_name'], $messageData['time_unix']);
        if (!array_key_exists($logKey, $logData)) {
            // XXX we did not find a matching connect entry...
            // just ignore it
            continue;
        }
        $dataTransferred = $messageData['bytes_sent'] + $messageData['bytes_received'];

        $logData[$logKey] = array_merge(
            $logData[$logKey],
            [
                'disconnect_time' => $messageData['disconnect_time_unix'],
                'traffic' => $dataTransferred,
            ]
        );
    }
}

echo json_encode(
    [
        'entries' => array_values($logData),
    ]
);
