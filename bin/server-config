#!/usr/bin/php
<?php

/**
 * Copyright 2015 FranÃ§ois Kooman <fkooman@tuxed.net>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
require_once dirname(__DIR__).'/vendor/autoload.php';

use fkooman\VPN\Server\ServerConfig;
use fkooman\Config\Reader;
use fkooman\Config\YamlFile;
use GuzzleHttp\Client;
use fkooman\VPN\Server\IPv4;
use fkooman\VPN\Server\IPv6;
use fkooman\VPN\Server\Utils;

function showHelp(array $argv)
{
    $helpText = sprintf('SYNTAX: %s [--reuse] [CN]', $argv[0]);
    $helpText .= PHP_EOL;
    $helpText .= '--reuse    use the existing keys and certificates instead of generating again'.PHP_EOL;
    $helpText .= 'CN         the common name for the certificate, typically the hostname'.PHP_EOL;
    echo $helpText;
}

try {
    $dhLength = 3072;

    $reUse = false;
    $commonName = false;

    for ($i = 1; $i < $argc; ++$i) {
        if ('--reuse' === $argv[$i]) {
            $reUse = true;
        } else {
            $commonName = $argv[$i];
        }
    }

    if (false === $reUse && false === $commonName) {
        showHelp($argv);
        throw new Exception('must specificy either CN or --reuse flag');
    }

    $mainConfig = new Reader(
        new YamlFile(dirname(__DIR__).'/config/config.yaml')
    );

    $ipConfig = new Reader(
        new YamlFile(dirname(__DIR__).'/config/ip.yaml')
    );

    $openVpnConfig = $mainConfig->v('openVpn');

    if ($reUse) {
        // open the first file to extract the data
        $fileSuffix = array_keys($openVpnConfig)[0];
        $configFile = sprintf('/etc/openvpn/server-%s.conf', $fileSuffix);
        $configData = Utils::extractCertificates(file_get_contents($configFile));
        // XXX fix this in vpn-ca-api to return tls-auth instead of ta
        $configData['ta'] = $configData['tls-auth'];
    } else {
        // get a new certificate, and also generate a new DH
        $client = new Client(
            [
                'defaults' => [
                    'headers' => [
                        'Authorization' => sprintf('Bearer %s', $mainConfig->v('remoteApi', 'vpn-ca-api', 'token')),
                    ],
                ],
            ]
        );

        $requestUri = $mainConfig->v('remoteApi', 'vpn-ca-api', 'uri');

        $configData = $client->post(
            $requestUri.'/certificate/',
            [
                'headers' => [
                    'Accept' => 'application/json',
                ],
                'body' => [
                    'common_name' => $commonName,
                    'cert_type' => 'server',
                ],
            ]
        )->json();

        $configData = $configData['certificate'];

        $dhFile = tempnam(sys_get_temp_dir(), 'dh_');
        Utils::exec(sprintf('/usr/bin/openssl dhparam -out %s %d >/dev/null 2>/dev/null', $dhFile, $dhLength));

        if (false === $dhContent = @file_get_contents($dhFile)) {
            throw new Exception('unable to read DH file');
        }

        $configData['dh'] = trim($dhContent);
        @unlink($dhFile); // we don't care if this fails
    }

    $serverConfig = new ServerConfig();

    $instanceCount = count($openVpnConfig);
    $ip4 = new IPv4($ipConfig->v('range'));
    $ip6 = new IPv6($ipConfig->v('range6'));

    $ip4Ranges = $ip4->splitRange($instanceCount);
    $ip6Ranges = $ip6->splitRange($instanceCount);

    $dns = $ipConfig->v('dns');
    $twoFactor = $ipConfig->v('twoFactor', false, false);
    $clientToClient = $ipConfig->v('clientToClient', false, false);

    $routes = $ipConfig->v('routes', false, []);

    $i = 0;
    foreach ($openVpnConfig as $k => $v) {
        $ipConfig = [
            'v4_prefix' => $ip4Ranges[$i],
            'v6_prefix' => $ip6Ranges[$i],
            'routes' => $routes,
            'dns' => $dns,
            '2fa' => $twoFactor,
            'c2c' => $clientToClient,
        ];

        $instanceConfig = [];
        $instanceConfig['dev'] = sprintf('tun-%s', $k);

        // determine the listen address
        if (!array_key_exists('listen', $v)) {
            if ('udp' === $v['proto']) {
                $instanceConfig['listen'] = '::';
            } else {
                // sniproxy + iOS + tcp6-server has issues, not sure what 
                // exactly is going on, but it does not work. Fortunatly 
                // sniproxy will take care of IPv6 and IPv4 TCP connections
                $instanceConfig['listen'] = '0.0.0.0';
            }
        } else {
            $instanceConfig['listen'] = $v['listen'];
        }

        // determine the proto, based on whether the listen address is v4 or v6
        $is6 = false !== strpos($instanceConfig['listen'], ':');
        if ('udp' === $v['proto']) {
            $instanceConfig['proto'] = $is6 ? 'udp6' : 'udp';
        } else {
            $instanceConfig['proto'] = $is6 ? 'tcp6-server' : 'tcp-server';
        }
        $instanceConfig['port'] = $v['port'];
        $instanceConfig['management_port'] = $v['managementPort'];
        $vpnConfig = implode(PHP_EOL, $serverConfig->get(array_merge($instanceConfig, $ipConfig, $configData)));
        file_put_contents(sprintf('/etc/openvpn/server-%s.conf', $k), $vpnConfig);

        ++$i;
    }
} catch (Exception $e) {
    echo $e->getMessage().PHP_EOL;
    exit(1);
}
